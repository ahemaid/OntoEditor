<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta
      name="author"
      content="Ahmad Hemid, Waleed Shabbir, Dr.Abderrahmane Khiat, "
    />
    <meta
      name="keywords"
      content="OntoEditor, Real-time collaboration, RDF serialization, Version Control Systems, Git integration, Error detection, Syntax validation,
      Ontology development, ontologies, semantic web"
    />
    <meta
      name="description"
      content="OntoEditor - Web-based Visualization of Ontologies"
    />
    <meta name="robots" content="noindex,nofollow" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700,700i&display=swap"
      rel="stylesheet"
    />
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <style>
      body {
        font-family: "Roboto";
      }

      button {
        background-color: cornflowerblue;
        color: white;
        border-radius: 5px;
      }

      .loader {
        border: 4px solid #f3f3f3;
        border-radius: 50%;
        border-top: 4px solid #3498db;
        width: 30px;
        height: 30px;
        -webkit-animation: spin 2s linear infinite;
        /* Safari */
        animation: spin 2s linear infinite;
      }

      /* Safari */
      @-webkit-keyframes spin {
        0% {
          -webkit-transform: rotate(0deg);
        }

        100% {
          -webkit-transform: rotate(360deg);
        }
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
    </style>
    <style>
      .class-inner {
        margin: 3px;
        border-style: dashed;
        border-color: beige;
        cursor: pointer;
      }

      /* Add Animation */
      @-webkit-keyframes animatetop {
        from {
          top: -300px;
          opacity: 0;
        }

        to {
          top: 0;
          opacity: 1;
        }
      }

      @keyframes animatetop {
        from {
          top: -300px;
          opacity: 0;
        }

        to {
          top: 0;
          opacity: 1;
        }
      }

      /* The Close Button */
      .close {
        color: white;
        float: right;
        font-size: 28px;
        font-weight: bold;
      }

      .close:hover,
      .close:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
      }

      .modal-header {
        padding: 2px 16px;
        background-color: rgb(113, 155, 211);
        color: white;
      }

      .modal-body {
        padding: 2px 16px;
      }

      .modal-footer {
        padding: 2px 16px;
        background-color: #fff;
        color: white;
      }
    </style>
    <style>
      /* End Reset */

      /* Default Font Styles
______________________*/
      .section-wrap {
        width: 100%;
        font-family: "Open Sans", sans-serif;
      }

      .section-wrap .section {
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
      }

      .section-wrap .top-section {
        border-bottom: 1px solid #34495e;
        padding-bottom: 15px;
        margin-bottom: 15px;
        text-align: center;
      }

      .section-wrap .top-section a {
        color: #69c;
        font-size: 14px;
      }

      .section-wrap .top-section a:hover {
        color: #007bff;
      }

      .section-wrap .heading-section {
        text-align: center;
        padding-bottom: 20px;
      }

      .section-wrap .heading-section h2 {
        font-size: 18px;
      }

      .section-wrap .img-wrap {
        padding-bottom: 10px;
        border-bottom: 2px solid #fff;
        margin-bottom: 15px;
      }

      .section-wrap .img-wrap img {
        display: block;
        width: 100%;
        height: auto;
      }

      .section-wrap .tab-label {
        font-weight: bold;
        padding-bottom: 10px;
        display: block;
        cursor: pointer;
      }

      .section-wrap .tab-label em {
        font-style: normal;
        float: left;
        width: 80%;
        font-size: 16px;
      }

      .section-wrap .tab-label span {
        text-align: right;
        float: right;
        width: 15%;
        font-size: 16px;
      }

      .section-wrap-prop .tab-content {
        display: none;
      }

      .section-wrap .tab-content {
        display: none;
      }

      .datatype-content ul {
        padding: 0;
      }

      .datatype-content li {
        border-bottom: 1px solid #ccc;
        padding-bottom: 10px;
        margin-bottom: 10px;
        list-style: none;
      }

      .datatype-content .data-heading {
        display: inline-block;
        cursor: pointer;
      }

      .datatype-content .data-heading span {
        display: block;
        padding: 3px 10px;
        border: 2px solid #9467bd;
        -moz-border-radius: 4px;
        -webkit-border-radius: 4px;
        -o-border-radius: 4px;
        border-radius: 4px;
        font-weight: bold;
        text-align: center;
        font-size: 13px;
      }

      .datatype-content .data-text {
        display: inline-block;
      }

      .datatype-content .data-text span {
        font-style: normal;
        font-size: 13px;
      }

      .datatype-content .data-text span::before {
        content: ":";
        margin-right: 5px;
      }

      .datatype-content.block-li .data-heading {
        width: 100%;
        margin-bottom: 5px;
      }

      .datatype-content.block-li .data-text {
        display: block;
        text-align: center;
      }

      .datatype-content.block-li .data-text a {
        color: #bdc3c7;
      }

      .datatype-content.block-li .data-text span::before {
        content: "";
        margin-right: 0;
      }

      .tabs-wrap .tab {
        margin-bottom: 20px;
      }

      .tabs-wrap .tabs .tab:last-child {
        margin-bottom: 0;
      }

      .innertab {
        padding: 5px;
        margin-bottom: 5px;
      }

      .innertab label {
        display: block;
        font-weight: bold;
        cursor: pointer;
        border: 2px solid #2e855e;
        font-size: 14px;
        border-radius: 2px;
        padding: 5px;
        color: black !important;
        position: relative;
      }

      .innertab label::after {
        content: "V";
        /* background: url(images/down.png) no-repeat center center; */
        background-size: 100% auto;
        position: absolute;
        right: 5px;
        top: 5px;
        z-index: 999;
        width: 15px;
        height: 15px;
      }

      .innertab label.active::after {
        content: "^";
        background: url(images/up.png) no-repeat center center;
        background-size: 100% auto;
        position: absolute;
        right: 5px;
        top: 5px;
        z-index: 999;
        width: 15px;
        height: 15px;
      }

      .innertab .tab-content {
        padding: 10px 10px 0 10px;
      }

      .innertab .tags-content {
        text-align: center;
      }

      .innertab .tags-content span {
        display: inline-block;
        padding: 3px 10px;
        border: 2px solid #9467bd;
        -moz-border-radius: 4px;
        -webkit-border-radius: 4px;
        -o-border-radius: 4px;
        border-radius: 4px;
        font-weight: bold;
        text-align: center;
        font-size: 11px;
        cursor: pointer;
      }

      .object-content ul {
        padding: 0;
      }

      .object-content li {
        list-style: none;
      }

      /* Accordion styles */

      .clearfix:after {
        clear: both;
        content: " ";
        display: block;
        font-size: 0;
        line-height: 0;
        visibility: hidden;
        width: 0;
        height: 0;
      }
      .container {
        padding: 50px;
      }

      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
      }

      table {
        border-collapse: collapse;
        width: 100%;
      }
      th,
      td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #f2f2f2;
      }
    </style>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <title>OntoEditor Docs</title>
  </head>

  <body>
    <div id="myHelp" class="container">
      <div>
        <h1>OntoEditor Documentation</h1>
        <p style="text-align: center">
          <a href="#Overview">Overview</a> •
          <a href="#Architecture">Architecture</a> •
          <a href="#Motivation">Motivation</a> •
          <!-- <a href="#Features">Features</a> • -->
          <a href="#Implementation">Implementation</a> •
          <a href="#Installation">Installation</a> •
           <!-- <a href="#FAQ">FAQ</a> • -->
          <a href="https://github.com/ahemaid/OntoEditor">Source Code</a> •
          <a href="https://github.com/ahemaid/OntoEditor/blob/main/LICENSE"
            >License</a>
          • <a href="mailto:ahmad.hemid@fit.fraunhofer.de">Contact</a>
        </p>
      </div>
      <div id="Overview">
        <h2><u>Overview:</u></h2>
        <div>
          <p style="font-size: 16px; text-align: justify">
            Online Collaborative Ontology Editor (OntoEditor) on top of Distributed Version Control Systems is 
            an approach towards supporting collaborative
            developing ontologies with syntax parsing in different RDF serialization formats,
            such as Turtle, Json-LD, and RDF/XML.
          </p>
        </div>
      </div>
      <div id="Motivation">
         <h2><u>Motivation:</u></h2>

        <div>
          <p>
            John, Robert, and Lisa, experienced ontology engineers, face challenges in 
            collaborative ontology development. Current tools lack real-time collaboration, syntax checking,
             and efficient communication. To streamline this, we've devised a solution enabling real-time collaborative editing,
              live syntax checking, and instant communication. 
          </p>

          <p>
            Users work on a shared document, seeing each other's changes, 
            cursor positions, and syntax errors in real-time. Discussions happen through live chat, resolving errors collaboratively. 
            Only authorized users can commit changes to the remote repository. This approach simplifies collaboration, 
          ensuring real-time error detection and synchronization with the remote repository.
          </p>
          <img
            style="width: 50%; padding-bottom: 2%"
            src="Images/motivation.png"
            alt="KGraphX Architecture"
          />
 
        </div> 
      </div>
      <div id="Architecture"></div>
      <div id="Architecture">
         <h2><u>OntoEditor Architecture and Workflow:</u></h2>
        <div>
          <p style="font-size: 16px; text-align: justify">
            The architecture of OntoEditor consists of several components designed to serve as a Streamlined Visual KG Builder
            specifically tailored for novice users. The main components are can be seen below in the coming diagram.          </p>
          <img
            style="width: 50%; padding-bottom: 2%"
            src="Images/collabImplementation.png"
            alt="KGraphX Architecture"
          />
        </div>
        <h2>Main Components:</h2>
        <ul>
          <li>
            <strong>Editor:</strong> CodeMirror  as a JavaScript-based Editor was selected for its robust programmable API and
             advanced editing capabilities like
            auto-indentation, auto-completion, syntax highlighting, and search functionalities. 
            As an open-source editor widely used in various projects, CodeMirror inherently supports syntax highlighting for 
            over a hundred programming languages,
            including Turtle, XML, and JSON-LD. Crucially, it enables collaboration by
            detecting changes through onChange events
          </li>
          <li>
            <strong>Real-Time Communication Channel:</strong> Real-time communication is vital for
            collaborative editing. WebSocket [6] technology enables immediate and bidirectional data exchange between web browsers
             (clients) and servers, facilitating seamless interactions. Upon initiating document editing, 
             a WebSocket connection is established. This channel relays all modifications to the server, managing
            live chat, user details, cursor positions, and notifications among connected users.
          </li>
          <li>
            <strong>ShareDB:</strong> To enable seamless collaboration, a real-time database was imperative. 
            After careful research, ShareDB 2
            emerged as the optimal choice. ShareDB,
            The below figure shows OntoEditor’s Workflow. The diagram illustrates the authentication
            process in Git, file selection, and the initiation of RDF editing. It highlights the
            collaborative nature facilitated by a unique shareable link, enabling simultaneous
            editing and syntax checking. Completed changes can be committed and pushed
            to the remote repository.
            built on Operational Transformation, operates as a real-time in-memory
            database. It stores JavaScript objects on the server and facilitates their sharing among multiple clients through WebSockets.
             Documents in ShareDB include
            properties like Version (incrementing from 0), Type (e.g., OT-text, OT-json1),
            and Data which is the intended content for storage within the database.
            Algorithm 1 was designed to operationalize this approach. Upon a user’s initiation of RDF document editing,
             a new document with an initial version of 0 and
            the RDF data to be inserted is created in ShareDB. If the document already
            exists in ShareDB, its existing path is returned to the user. For Operational
            Transformation, we leverage Plain text Operational Transformation. This Operational Transformation type is utilized for editing plain text documents and
            supports operations including skipping forward N characters, inserting str at the
            current position, and deleting N characters at the current position.
            Clients subscribe to ShareDB documents, updating the document’s state
            with insertions and deletions by modifying the index position and content. Each
            change increments the version number and is stored in ShareDB. These operations are transmitted over WebSockets, 
            updating connected clients’ local document states.
            
          </li>
          <li>
            <strong>RDF Validator:</strong> OntoEditor utilizes JavaScript parser libraries for real-time validation of var-
            ious RDF serialization formats (Turtle, RDF/XML, JSON-LD). Users receive
            instantaneous error messages and can rectify syntax errors seamlessly during
            editing. To validate RDF, established parsers are employed: N3.js for Turtle,
            RDF/XML streaming parser 2 for RDF/XML, and JSON-LD streaming parser 
            for JSON-LD. These parsers operate in a streaming manner, ensuring efficient
            handling of large documents with limited memory.
            During the editing process, users can select their desired format. The chosen
            parser is activated accordingly, integrated with an onChange function to auto-
            matically check syntax while typing. The syntax checker can be toggled on or off,
            with default activation. The syntax checker identifies the format from the URL
            path and calls the corresponding parser. Parsing occurs in a streaming manner,
            providing parsed triples and highlighting any syntax errors. Meaningful error
            messages are displayed atop the editor for immediate user visibility. Upon error
            correction, a ’Syntax correct, all triples parsed successfully’ message is shown
          </li>
        </ul>
        <img
        style="width: 50%; padding-bottom: 2%"
        src="Images/FlowChart.png"
        alt="KGraphX Architecture"
      />
      </div>
      <!-- <div id="Features"> -->
        <!-- <h2><u>Features:</u></h2>
        <div>
          <h3>Visual Elements</h3>
          <p>
            KGraphX focuses on making it easier for lay users to understand and
            use the tool for knowledge graph creation. It uses visual elements
            to represent different categories: Resource, Property, and Datatype.
            Each element is depicted with a symbol and a natural language term,
            making it more understandable for lay users.
          </p>
          <img
            style="width: 35%; padding-bottom: 2%"
            src="Images/visual.png"
            alt="Visual Elements"
          />

          <h3>Building the Knowledge Graph</h3>
          <p>
            Resources can be created using the drag-and-drop approach. Users can
            search for entities in Wikidata or Bioportal and create new
            entities. The graph building process can be done with or without the
            force layout enabled. Relations between entities can be established
            by dragging the arrowhead to the target element. Two types of
            properties, HasRelation and isTypeOf, can be used for creating
            relations. Users can also reuse existing properties from Wikidata to
            create relationships between resources.
          </p>
          <img
            style="width: 70%; padding-bottom: 2%"
            src="Images/KGraphX_Interface.png"
            alt="KGraphX UI"
          />
          <h4>Wikidata and Bioportal Integration</h4>
          <h5>Wikidata</h5>

          KGraphX integrates with Wikidata using its API. Users can get search
          suggestions and populate existing properties of an entity by invoking
          the Wikidata API with corresponding SPARQL queries.

          <h5>Bioportal</h5>
          <p>
            Bioportal integration requires an API key. Users can search for
            entities and select the required entity to build the graph. The
            resource node will be populated with the label name, and the IRI
            value takes the URL value.
          </p>

          <h4>Export Module</h4>
          <p>
            KGraphX provides an export module for serializing the constructed
            graph into RDF and RDFS formats. Users can select the export option,
            and the content will be prepared in steps to create the header,
            prefixes, and required syntax formats. The exported file can be
            downloaded as a TTL format file.
          </p>
          <img
            style="width: 35%; padding-bottom: 2%"
            src="Images/exportFlowchart.png"
            alt="Export Module"
          />

          <h4>Apache Jena Fuseki Integration</h4>
          <p>
            KGraphX integrates with Apache Jena Fuseki, which acts as a
            repository for storing and managing RDF data associated with
            KGraphX-created KGs. Users can run the Fuseki server at port 3030
            and use it as a centralized storage solution for ontologies and RDF
            data.
          </p>
        </div> -->
      <!-- </div> -->
      <div id="Implementation">
        <h2><u>OntoEditor Implementation:</u></h2>
        <div>
          <p>
             Referencing the following Figure
, OntoEditor has 3 modules. The first module is responsible for remote repository
communication, the second module is responsible for enabling collaboration and
finally the third module is responsible for syntax validation.

          </p>
          <img
style="width: 50%; padding-bottom: 2%"
src="Images/impModules.png"
alt="OntoEditor"
/>
          <h3> Repository Communication:</h3>
          <p>
            Given the requirement to provide a low-threshold access to the repository, we decided to prioritize the availability 
            of a web interface over the underlying version ntrol system. GitHub, Gitlab and Bitbucket, these three 
            repository hosting services
             provide a RESTFUL API architecture. By consuming REST API’s, we allow
            users to communicate directly with their repository. This is useful especially for
            those users who prefer editing RDF in a web based client and don’t want to install
            GIT in their local machines.
            In order to take advantage of OntoEditor, users have to authenticate themselves
            with these repository hosting services. The authentication can be based on the
            username, password or personal access token. Since with Github and Gitlab, the
            authentication is only possible with a personal access token as they do not provide
            support for the username or password authentication anymore. The Bitbucket users
            can still take advantage of both authentication methods. After authentication,
            we show users the list of their repositories and all the branches in the respective
            repository. A typical fetch request is shown in the below Fetching Script. . Here we call the Gitlab
            Rest API to get the projects/repositories of a user whose credentials are passed in
            headers of request.
            <p>
              <pre>
                <code>
                  //Fetching Script: Fetching repositories of user
                  fetch (" https :// gitlab .com/api/v4/ projects ? owned = true ", {
                    headers : { Authorization : " Bearer " + token } ,
                    })
                    . then ( function ( response ) {
                    if ( response .ok) {
                    response . json () . then (( data ) = > {
                    res . status (200) . json ({ repos : data }) ;
                    }) ;
                    } else {
                    res . status (400) . json ({ err : response . statusText }) ;
                    }
                    })
                    . catch ( function ( error ) {
                    res. status (400) . json ({ err : error . statusText }) ;
                    }) ;
                    
                </code>
                </pre>
            The files are then filtered based on the file format. We will only show files with
extensions (’.ttl’), (’.rdfxml’), (’.jsonld’), (’.rdf’), (’.json’) and (’.txt’). All the other
files in the repository will be ignored. We allow the users to add new files in their
repository if they want to start building an ontology from scratch. Further, a delete
file option is also available if they want to delete any of their files. The coming Figure 
shows list of repositories and files returned by Github and how we display them
in dropdown menus. Based on the user selection, we get the file and display it on
our web frontend that they can use to start the editing process. After developing
the ontology they can commit their changes to the repository. Users can share
their editing link with other users but for committing changes, the authentication
is always required and only those users will be able to commit, who have access to
that respective repository.
</p>

 
<img
style="width: 30%;  padding-bottom: 2%"
src="Images/repo-info.JPG"
alt="OntoEditor"
/>
<p>

A scenario can happen when user A edits the file from the repository directly. This
will update the SHA1 of their file, and if user B is already editing on our editor,
then there could be a GIT conflict. Since, while committing we completely push
the new content which will replace the complete file on the repository. We wanted
the user to be able to see if there are any new commits in their repository. For this,
we keep checking the history of file in an interval of 60 seconds, and manifest it on
the editor with the name of the last committer and the time of the last commit.
This way, the user can know if there have been any new changes.
Nevertheless, if the user wants to commit the file, we show them diff screen while
making use of <a href="https://mergely.com/ ">Mergely </a> Javascript library. We then show the difference between the
          </p>



          <p>
            two files and provide options to merge the content line by line or entirely. Inspired
            by how Visual Studio handles GIT conflict, we decided to implement this feature.
            The user can then see the latest file on the repository and the local editor state
            of the document in a side by side comparison. They can compare the parts to be
            merged or replaced before committing. As shown in the below Figure , user B was editing
            in our editor whilst user A pushed some new changes from Github directly. We
            then show a merge screen to user B where they can select the changes they want to
            keep or discard before committing them.
                    </p>

                    <img
                    style="width: 50%; padding-bottom: 2%"
                    src="Images/mergely.png"
                    alt="OntoEditor"
                  />



          <h3>Collaboration</h3>
          <p>
            The collaboration service is implemented as a separate module which communicates 
            over Websocket traffic rather than HTTP traffic. Due to a large number of
            editing operations, the idea was to extract the complexity of collaboration into an
            independent microservice.
          </p>

          <!-- <pre>
            <code>
        function searchFunction() {
            let searchInput = document.getElementById('searchInput').value;
            let searchResults = [];
        
            // Iterate over all nodes in the graph
            // Check if the label or IRI matches the search input
            // If yes, push the node to the searchResults array
        
            // Highlight the searchResults nodes in the graph
        }
            </code>
            </pre> -->

          <h3>RDF Validation and Error Reporting</h3>
          <p>
            we will be using JavaScript parser libraries for validating
            different RDF serialization formats. While starting the editing process, a user can
            select ”turtle”, ”rdf/xml”, or ”jsonld” format. Based on the user’s selection we
            will use a parser for that serialization format. Just like we used onChange function
            for insertion and deletion, we will also connect our syntax checker function with
            it. This will ensure that every time a user types something, the syntax is checked
            automatically. The user can choose to enable or disable the syntax checker, which
            by default is always activated.
            Syntax checker functions first detects the format from the URL path of the RDF
            serialization format. Contingent upon the format, we call the parser for that specific
            format. All the content in the document is then passed to our parser. Parser then
            parses the input in a streaming way, and returns us parsed triples and any syntax
            errors in the input. We display meaningful error messages on top of the editor in
            order that the user can read them anytime. As soon as the user corrects the error,
            a success message is displayed ”All triples are parsed, Syntax correct”.
          </p>

        </div>
        <!-- <div>
          <h3>Export module</h3>
          <p>
            The export module covers the logic for exporting the knowledge
            graphs in TTL format in RDF and S serializations. It is organized in
            two separate files <em>exportMenu.js</em> and
            <em>exportTTLModule.js</em>.
          </p> -->

          <!-- <figure>
            <img
              style="width: 50%; padding-bottom: 2%"
              src="Images/exportUML.png"
              alt="UML Diagram for  RDF and RDFS serialization"
            />
             <figcaption style="text-align: center">UML Diagram for  RDF and RDFS serialization</figcaption> 
          </figure> -->
          <!-- <p>
            The process flow for syntax construction involves multiple modules:
          </p> -->
          <!-- <ul>
            <li>
              <strong>Export Menu:</strong> The export menu is added in the
              footer section with options for <em>Export as RDF</em>,
              <em>Export as RDFS</em>, <em>Upload TTL file to Fuseki</em>, and
              <em>Upload current graph to Fuseki</em>. It sets the file name and
              file type for the download functionality.
            </li>
            <li>
              <strong>Prepare headers and prefix list:</strong> The content for
              the TTL file is constructed in various steps. It begins with two
              functions, <em>prepareHeader()</em> and
              <em>preparePrefixList()</em>, that add the required text to the
              header section and set the required prefixes for the syntax,
              respectively. <em>preparePrefixRepresentation()</em> prepares the
              IRI values of each of the nodes and links in the graph.
            </li>
            <li>
              <strong>Get Resource and Property data:</strong> For the graph
              drawn, the node and link details are fetched and the data is
              stored in an object. This provides all the required data regarding
              the resources and properties have been drawn in the graph in two
              separate objects, which can be used to construct the required
              serializations.
            </li>
            <li>
              <strong>Constructing the RDF syntax:</strong> The RDF syntax is
              constructed by setting the subject, predicate, and object values
              into the resultant content. Since the elements are represented in
              the prefix formats, which are their IRI values, for better
              understanding, each of the element's label is added using the
              property
              <code>&lt;http://www.w3.org/2006/vcard/ns#hasFN&gt;</code>. The
              resulting content is received at the main export module, which is
              included in the content for download.
            </li>
            <li>
              <strong>Constructing the RDFS Format:</strong> Similar to RDF
              syntax construction, the RDFS syntax generation also follows a
              similar structure. In this case, there are two separate methods to
              construct the schema for properties and resources in a triple
              structure. The obtained results from the two functions are
              appended and added to the contents to be exported.
            </li>
          </ul> -->
        <!-- </div>  -->
      </div>
      <div id="Installation">
        <h2><u>Installation:</u></h2>
        <div>
          <h3>Requirements</h3>
          <ul>
            <li>
              Node.js for installing the development tools and dependencies from
              <a href="https://nodejs.org/en">here</a>.
            </li>
            <!-- <li>
              Java Runtime Kit (JRE) or Java Development Kit (JDK) >= version
              11.
            </li> -->
          </ul>
          <h3>OntoEditor Installation</h3>
          <ol>
            <li>Navigate to the root folder.</li>
            <li>
              Run <code>npm install </code> to install the dependencies
              and build the project.
            </li>
            <li>
              Run <code>npm start</code> 
            </li>
            <li>
              Then, OntoEditor GUI is accessible at
              <a href="http://localhost:5000/">http://localhost:5000/</a> 
            </li>
          </ol>
          <!-- <h3>Fuseki Server Installation</h3>
          <ol>
            <li>
              You can download the latest version normally under their
              <a href="https://jena.apache.org/download/index.cgi">website</a>
              or download the Fuseki server with the following command for Linux
              machines. For Windows, the website has a Windows version
              <a
                href="https://dlcdn.apache.org/jena/binaries/apache-jena-fuseki-4.8.0.zip"
                >here</a
              >:
            </li>
            <pre><code>wget https://downloads.apache.org/jena/binaries/apache-jena-fuseki-4.8.0.tar.gz</code></pre>
            <li>Extract the compressed file.</li>
            <li>Find the location of "apache-jena-fuseki-4.8.0".</li>
            <li>Login to the terminal under the extracted folder.</li>
            <li>Run Fuseki using the following command:</li>
            <pre><code>./fusekiserver --update --mem --port=3030 /dataset</code></pre>
            <li>
              Fuseki server GUI is accessible at
              <a href="http://localhost:3030/">http://localhost:3030/</a> and as
              a default "dataset" will be used. Please remember to use it when
              exporting RDF/RDFS to the Fuseki server..
            </li>
          </ol> -->
          <h3>Running Using Docker</h3>
          <ol>
            <li>
              You can also run OntoEditor using docker, If you have it installed on
              your machine, otherwise, you use
              <a href="https://docs.docker.com/engine/install/">this</a>
              to install docker. Once you have docker, then you can issue the
              following command to download the OntoEditor docker image:
            </li>
            <pre><code>docker pull ahemid/ontoeditor</code></pre>
            or you can create OntoEditor docker image by giving the following
            command on the project root folder:
            <pre><code>docker build .  -t ahemid/ontoeditor</code></pre>
            <li>
              Next, create the ontoeditor docker container using the following
              command:
              <pre><code>docker run -d -p 5000:5000 -p 8080:8080 ahemid/ontoeditor </code></pre>
            </li>
            <li>
              Then, OntoEditor GUI is accessible at
              <a href="http://localhost:5000/">http://localhost:5000/</a> 
            </li>
          </ol>
        </div>
      </div> 
      <!-- <div id="FAQ"> -->
        <!-- <h2><u>Frequently Asked Questions for KGraphX Usage:</u></h2>
        <div>
          <div>
            <b style="font-size: 16px"
              >1. Selecting the required data store for search</b
            >
          </div>
          <ul>
            <li>
              Select Wikidata or Bioportal from the dropdown in the left sidebar
            </li>
          </ul>
          <img
            style="width: 25%; padding-bottom: 2%"
            src="Images/dropdown.PNG"
            alt="Datastore selection"
          />
        </div>
        <div>
          <div>
            <b style="font-size: 16px"
              >2. How do I create a resource and search for existing elements
              from the selected datastore?</b
            >
          </div>
          <ul>
            <li>Drag and drop a resource from the left sidebar</li>
            <li>Double click on the element</li>
            <li>Type inside the search box</li>
            <li>
              Select an element from the search results and you can find the
              results under Property details on the right side
            </li>
          </ul>
          <img
            style="padding-bottom: 2%"
            src="Images/Resource.gif"
            alt="Resource creation"
          />
        </div>
        <div>
          <div>
            <b style="font-size: 16px">3. How do I create a new entity?</b>
          </div>
          <ul>
            <li>Drag and drop a resource from the left sidebar</li>
            <li>Double click on the element</li>
            <li>Type the name you would like to add to the new entity</li>
            <li>Click on the "create new entity" button</li>
          </ul>
        </div>
        <div>
          <div>
            <b style="font-size: 16px"
              >4. How to find existing properties between 2 entities?</b
            >
          </div>
          <ul>
            <li>
              Create 2 resources and connect them with the "hasRelation"
              property
            </li>
            <li>Double click on the property box</li>
            <li>
              Any existing relation between the entities will be displayed in
              the pop-up else create a new property using the "Create new
              property" button
            </li>
          </ul>
        </div>
        <div>
          <div>
            <b style="font-size: 16px"> 5. How to export TTL as RDF/RDFS?</b>
          </div>
          <ul>
            <li>
              Once the graph is constructed, select the option of "Export as
              RDF" or "Export as RDFS" under the Export/Save tab in the footer.
            </li>
          </ul>
        </div>
        <div>
          <div>
            <b style="font-size: 16px">
              6. How to add the graph or TTL to Apache Jena Fuseki server?</b
            >
          </div>
          <ul>
            <li>
              Once the graph is constructed, if you directly wish to upload the
              current graph, select "Upload current graph to Fuseki" by entering
              the dataset name on your Fuseki server, which has "dataset" as its
              default value.
            </li>
            <li>
              If you wish to upload a TTL file, select "Upload TTL file to
              Fuseki" by entering the dataset name on your Fuseki server.
              "dataset" is the default value if you have used the given
              installation instructions.
            </li>
          </ul>
        </div>
      </div> -->
    <!-- </div> -->
  </body>
</html>
